<!-- TODO: 
      User Interface:
      ☑️ Create piece component
      - Create piece deck component
      ☑️ Create player hand component
      - Create player card component
        - Rotatable pieces????? 🤔
      - Create opponent card component
      - Create "I'm done" button
      - Create "Wait no I'm not!!" button

      Game Logic:
      - Setup colyseus server
      - Setup colyseus client
      - Learn about how colyseus manages game state
      - Determine flow and steps of game
      
      Game entities to track:
      - Deck
      - Player's Hand
      - Opponent's Hands
        - Must be server side
        - Actually everything should be server side because people could
          manipulate the game state on the client side.
      - Player's Card
        - Pieces on the card
        - Piece positions 
        - Piece rotations
      - Opponent's Card
        - Same as player's card
      - All players' scores
      - Player statuses
        - Done
        - Still playing
      
      Thoughts:
        - Maybe the game shouldn't be very strict about the rules.
        - Maybe it just lets players have their little cards and then show them to people?
        - That's how it will start, then more game logic can be added.
        - Server will still need to manage state for all of the above
-->
<script lang="ts">
	import { tick } from 'svelte';

	import Piece from './Piece.svelte';
	import type PieceType from './Piece.svelte';
	import PlayerDeck from './PlayerDeck.svelte';
	import PlayerCard from './PlayerCard.svelte';
	import type PlayerCardType from './PlayerCard.svelte';

	const abcWordList = [
		'adventure',
		'balloon',
		'chocolate',
		'dinosaur',
		'elephant',
		'flamingo',
		'giraffe',
		'hippo',
		'igloo',
		'jellyfish',
		'kangaroo',
		'lion',
		'monkey',
		'nurse',
		'octopus',
		'penguin',
		'quail',
		'rabbit',
		'snail',
		'tiger',
		'unicorn',
		'vulture',
		'wasp',
		'x-ray',
		'yak',
		'zebra',
		'aardvark',
		'baboon',
		'camel',
		'dolphin',
		'eel',
		'ferret',
		'gnu',
		'gopher',
		'hippopotamus',
		'iguana',
		'jackal',
		'kitten'
	];

	let playerDeckTop: number;
	let playerDeckBottom: number;
	let playerDeckRight: number;
	let playerCard: PlayerCardType;
	const piecesInHand: PieceType[] = [];
	let movedPieces = new Map<number, string>();
	let movedCoords = new Map<number, number[]>();
	const moving = { x: 0, y: 0 };

	const handleDragEnd = async (pieceBottom: number, index: number) => {
		if (pieceBottom > playerDeckTop) {
			await tick();
			piecesInHand[index].resetPiece();
			if (movedPieces.delete(index)) {
				movedPieces = movedPieces;
				movedCoords.delete(index);
			}
		} else {
			await tick();
			piecesInHand[index].outOfTray();
			const cardCoords = playerCard.getBounds();
			if (moving.x < cardCoords.left) {
				moving.x = cardCoords.left;
			}
			if (moving.y < cardCoords.top) {
				moving.y = cardCoords.top;
			}
		}
	};
</script>

<!-- This is the window which contains the game elements -->
{#each [...movedPieces] as [id, word]}
	<!-- make it so that Moved Piece has to
		stick to the card grid just using the features 
	of neodrag!!! -->
	<Piece
		{word}
		{id}
		x={movedCoords.get(id)?.at(0)}
		y={movedCoords.get(id)?.at(1)}
		clone={true}
		on:drag={({ detail: { left, top } }) => {
		}}
		on:dragEnd={async ({ detail: { bottom, left, top, right } }) => {
			moving.x = left;
			moving.y = top;
			await handleDragEnd(bottom, id);
			movedCoords = movedCoords.set(id, [moving.x, moving.y]);
			moving.x = 0;
			moving.y = 0;
		}}
	/>
{/each}

<PlayerDeck bind:top={playerDeckTop} bind:bottom={playerDeckBottom} bind:right={playerDeckRight}>
	{#each abcWordList as word, i}
		<Piece
			{word}
			id={i}
			bind:this={piecesInHand[i]}
			on:dragEnd={({ detail: { bottom } }) => {
				handleDragEnd(bottom, i);
			}}
			on:dragStart={() => {
				movedPieces = movedPieces.set(i, word);
				movedCoords = movedCoords.set(i, [-1000, -1000]);
			}}
			on:drag={({ detail: { left, top } }) => {
				// console.log(`dragStart: ${left}, ${top}, ${id}`);
				movedCoords = movedCoords.set(i, [left, top]);
			}}
		/>
	{/each}
</PlayerDeck>

<PlayerCard bind:this={playerCard}>Hello!</PlayerCard>

<style>
</style>
